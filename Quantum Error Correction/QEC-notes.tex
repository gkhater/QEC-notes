%===============================================
%   rhnotes.tex — Framework for RH-coding Notes
%===============================================
\documentclass[11pt,a4paper]{article}

%----- ENHANCED TYPOGRAPHY -----
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}        % clean vector font
\usepackage{microtype}      % better justification & kerning
\usepackage{palatino} 
\usepackage{braket}    % Palatino for text & math

%----- PAGE LAYOUT -----
\usepackage{geometry}
\geometry{top=1in, bottom=1in, left=1in, right=1in}
\usepackage{setspace}
\onehalfspacing  % 1.5 line spacing

%----- FANCY HEADERS & FOOTERS -----
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
% page number outside, header text inside
\fancyhead[LE]{\small Georges Khater}
\fancyhead[RE]{\small Notes on RH-coding}
\fancyhead[LO]{\small \rightmark}
\fancyhead[RO]{\small \leftmark}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

% make sections feed into \leftmark/\rightmark
\renewcommand{\sectionmark}[1]{\markboth{#1}{}}
\renewcommand{\subsectionmark}[1]{\markright{#1}}

%----- SECTION NUMBERING & TOC DEPTH -----
\setcounter{secnumdepth}{3}  % number down to \subsubsection
\setcounter{tocdepth}{2}     % show ToC down to \subsection

%----- AMS MATH & THEOREM STYLES -----
\usepackage{amsmath,amssymb,mathtools}
\usepackage{amsthm}

% definitions, examples, remarks upright
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{example}[definition]{Example}
\newtheorem{remark}[definition]{Remark}

% theorems, lemmas, corollaries italic
\theoremstyle{plain}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{corollary}[definition]{Corollary}

% unnumbered proof environment
\theoremstyle{remark}

%----- OTHER PACKAGES -----
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{calc, matrix, decorations.pathreplacing, positioning}
\usepackage{hyperref}
\hypersetup{colorlinks,
linkcolor=blue, citecolor=purple, urlcolor=teal}
\usepackage{enumitem}
\setlist[itemize]{nosep, left=1.5em}
\usepackage{booktabs}
\usepackage{listings}
\lstset{
basicstyle=\ttfamily\small,
numbers=left,
numbersep=5pt,
frame=single,
breaklines=true
}
\usepackage{xcolor}
\definecolor{shade}{HTML}{F5F5F5}
\usepackage{float}
%----- CUSTOM MACROS -----
\newcommand{\F}{\mathbb{F}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\bsc}{\mathrm{BSC}}
\newcommand{\dist}[2]{d\bigl(#1,#2\bigr)}

%----- TITLE METADATA -----
\title{\LARGE\bfseries Quantum Error Correction}
\author{Georges Khater \\ \small American University of Beirut}
\date{\today}

%===============================================
\begin{document}
\maketitle
\tableofcontents
\bigskip

\section{Introduction}
These notes are my personal take on \emph{A. Nielsen and I. Chuang's} book \emph{Quantum Computation and Quantum Information} (Cambridge University Press, 2010). More specifically, 
on the section related to Quantum Error Correction (and relevant sections). 
These notes will not serve as a replacement for the book, but rather as a supplement / summary of the relevant sections. They are meant to be 
used as a quick reference for the main ideas and results, and to help me (and hopefully others) remember the key concepts. 

\paragraph{Scope.}
The goal is to cover (in as much depth as possible) all the sections covered in the book, in addition to some of the relevant modern quantum code. 

\paragraph{Prerequisites.}
Prerequisites for these notes include basic understanding of Quantum Computation, Quantum Circuits and Quantum Operators. As well as basic knowledge of 
classical Error-correction (and their respective prerequisites).  

\section{Measures of distance} 

\subsection{Fidelity}

\begin{definition}\label{def:fidelity}
We define the \emph{fidelity} of states $\rho$ and $\sigma$ to ne 
$$F(\rho, \sigma) \equiv \operatorname{tr} \sqrt{\rho^{1/2} \sigma \rho^{1/2}}$$
While it is a measure of distance between two sotaotes, it is not a metric on quantum states (but gives rise to a useful one). 
\end{definition}

There are two important special cases where it is possible to give more explicit formulae for the fidelity. The first is when $\rho$ and $\sigma$ commute, that is, are diagonal in the same basis 
$$\rho = \sum_{i} r_i \ket{i} \bra{i}; \; \sigma = \sum_i s_i \ket{i} \bra{i}$$
for some orthonormal basis $\ket{i}$. In this case: 
\begin{align*}
F(\rho, \sigma) &= \sum_i \sqrt{r_i s_i}
\end{align*}
i.e when $\rho$ and $\sigma$ commute, the quantum fidelity reduces to the classical fidelity $F(r_i, s_i)$ between the eigenvalue distributions $r_i$ and $s_i$ of 
$\rho$ and $\sigma$ (how much the distributions overlap).

The second example is when computing the fidelity of a pure state $\ket{\psi}$ and an arbitrary state 
$\rho$. Notice that 
$$F(\ket{\psi}, \rho) = \sqrt{\braket{\psi | \rho | \psi}}$$
i.e Fiedlity is the square root of the overlap between $\ket{psi}$ and $\rho$.

\begin{proposition}
The fidelity is invariant under unitary transformations: 
$$F(U \rho U^\dagger, U \sigma U^\dagger) = F(\rho, \sigma)$$
\end{proposition}

\begin{theorem}[Uhlmann's Theorem] \label{thm:fidelity-purification}
Suppose $\rho$ and $\sigma$ are states of a quantum system $Q$. Introduce a second quantum system $R$ 
which is a copy of $Q$. Then 
$$F(\rho, \sigma) - \max_{\ket{\psi}, \ket{\varphi}} |\braket{\psi | \varphi}|$$
\end{theorem}

\begin{corollary}
Although this theorem is not necessarily useful for computing fidelity, it allows us to observe that: 
\begin{enumerate}
\item Fidelity is symmetric in its inputs: 
$$F(\sigma, \rho) = F(\rho, \sigma)$$

\item The fidelity is bounded between $0$ and $1$: 
$$0 \leq F(\rho, \sigma) \leq 1$$

\item The fidelity between a state and itself is $1$: 
$$F(\rho, \rho) = 1$$
Similarly, if $\rho \neq \sigma$ we get 
$$F(\rho, \sigma) < 1$$

\item $F(\rho, \sigma) = 0$ iff $\rho$ and $\sigma$ have support on orthogonal subspaces (intuitively its because they are perfectly distinguishable).  
\end{enumerate}
\end{corollary}

In analogy to the classical case, we can show that 
$$F(\rho, \sigma) = \min_{E_m} F(p_m, q_m)$$
Where the minimum is over all POVMS $\{E_m\}$ and $p_m = \operatorname{tr}(\rho E_m), \, q_m = \operatorname{tr}(\sigma E_m)$ which are the 
probability distributions for $\rho$ and $\sigma$ according to the POVM $\{E_m\}$. 

\paragraph{Properties of the fidelity} Although the fidelity is not a metric, it can easily be turned into one. 
The basic idea is that the \emph{angle} between two points on the sphere is a metric. For the quantum case, Uhlmann's theorem tells us that the 
fidelity between to states is the maximum inner product between purifications of those states. 

\begin{definition}
We define the \emph{angle} between states $\rho$ and $\sigma$ by 
$$A(\rho, \sigma) = \arccos F(\rho, \sigma)$$
This suggests in some sense that $F(\rho, \sigma)$ is the cosine of the angle between the states 
(This is justified from the discussion above). 
\end{definition}

\begin{proposition}
The angle defined above is a metric on the statespace. 
\end{proposition}

\begin{theorem}[Monotonicity of the fidelity]\label{thm:Monotonicity-fidelity}
Suppose that $\mathcal{E}$ is a trace-preserving quantum operation. Let $\rho$ and $\sigma$ be density operators. 
Moreover, these $\overline{Z}$ operators are indepedent from the first Then 
$$F(\mathcal{\rho}, \mathcal{\sigma}) \geq F(\rho, \sigma)$$
\end{theorem}

\begin{corollary}[Contractivity of the angle]\label{thm:contractivity-angle}
Since $\arccos$ is monotonically decreasing on $[0,1]$, 
$$A(\mathcal{E}(\rho), \mathcal{E}(\sigma)) \leq A(\rho, \sigma)$$
\end{corollary}

\begin{theorem}[Strong concavity of the fidelity]\label{thm:strong-concavity-fidelity}
Let $p_i$ and $q_i$ be probability distribution over the same index set, and $\rho_i$ and $\sigma_i$ density operators also indexed by the same index set. Then 
$$F \left(\sum_i p_i \rho_i, \sum_i q_i \sigma_i\right) \geq \sum_i \sqrt{p_i q_i} F(\rho_i, \sigma_i)$$
\end{theorem}

\begin{corollary}[Joint concavity of fidelity] \label{thm:joint-concavity-fidelity}
The fidelity is \emph{jointly concave}
$$F\left(\sum_i p_i \rho_i, \sum_i p_i \sigma_i\right) \geq \sum_i p_i F(\rho_i, \sigma_i)$$
\end{corollary}

\begin{corollary}[Concavity of fidelity] \label{thm:concavity-fidelity}
The fidelity is concave: 
$$F\left(\sum_i p_i \rho_i, \sigma\right) \geq \sum_i p_i F(\rho_i, \sigma)$$
By symmetry, it is also concave in the second entry.
\end{corollary}
\section{Introduction to QEC}
There are some important differences between classical error information and quantum information. 
This forces us to develop new ideas and techniques to make quantum error-correction possible. In particular: 
\begin{enumerate}
\item \emph{No cloning theorem:} Becaues we can't copy quantum states, even the simplest repetiton code are not easily implemented. 
Even if we could copy quantum states, we couldn't measure and copy the three quantum states output from the channel. 

\item \emph{Errors are continuous:} A continuum of erros might occur \emph{on a single qubit}. It may appear that error correction / detection 
would require infinite precision. 

\item \emph{Measurment destroys quantum information:} In classical-error correction, we observe the output from the channel, which allows us to 
decide which decoding procedure to apply. This is not feasible in quantum mechanics. 
\end{enumerate}
Fortunately, non of these problems are fatal, as we will see in the rest of the notes. 

\subsection{The three qubit bit flip code}

\begin{definition}
The \emph{bit flip channel} is a channel which leaves the qubits untouched with probability $1 - p$, and flips the qubits with probability $p$. 
i.e With probability $p$ the state $\ket{\psi}$ is taken to the state $X \ket{\psi}$, where $X$ is the Pauli $\sigma_x$ operator, or \emph{bit flip operator}. 
\end{definition}

\begin{definition}
The \emph{bit flip code} is a quantum error-correcting coe that may be used to protect the qubits against the effects of the bit flip channel. It is defined as follows. 

Suppose we encode the single qubit state $a \ket{0} + b \ket{1}$ in three qubits as $a \ket{000} + b \ket{111}$. We denote: 
\begin{align*}
\ket{0} \to \ket{0_L} \equiv \ket{000} \\
\ket{1} \to \ket{1_L} \equiv \ket{111}
\end{align*}
The notation $\ket{0_L}$ and $\ket{1_l}$ indicate that these are the \emph{logical} states. 
This encoding can be represented by a quantum circuit (as seen on page 428).
\end{definition}

Suppose the initial state $a \ket{0} + b \ket{1}$ has been perfectly encoded as $a \ket{000} + b \ket{111}$. 
Each of the three qubits is passed through an if and only if the rowsof the 
corresponding parity check matrix are linearly independent.  copy of the bit flip channel. Suppose a bit flip occured on one or fewer of the qubits. There is a simple 
two stage \emph{error-correction} procedure which can be used to recover the quantum state. 

\begin{enumerate}
\item \emph{Error-detection} or \emph{syndrome diagnosis:} We perform a measurement which tells us what error, if any, occured on the quantum state. 
We call this measurment the \emph{error syndrome}. For the bit flip channel there are four error syndromes, corresponding to the four projection operators. 
\center 
\begin{table}[h]
\centering
\begin{tabular}{c|c|l}
\hline
$j$ & $P_j$ & Description \\
\hline
$P_0$ & $\ket{000}\bra{000} + \ket{111}\bra{111}$ & no error \\
$P_1$ & $\ket{100}\bra{100} + \ket{011}\bra{011}$ & bit flip on qubit 1 \\
$P_2$ & $\ket{010}\bra{010} + \ket{101}\bra{101}$ & bit flip on qubit 2 \\
$P_3$ & $\ket{001}\bra{001} + \ket{110}\bra{110}$ & bit flip on qubit 3 \\
\hline
\end{tabular}
\end{table}


\item \emph{Recovery:} We use the value of the error syndrome to tell us what procedure to use 
to recover the initial state. 
For example, if the error syndrome was $1$, indicating a bit flip on the first qubit, then we flip that qubit again, recovering the initial state with perfect accuracy. We do the same for 
all other error syndromes. 
\end{enumerate}

\paragraph{Error analysis}

The error analysis is not as simple as in the classical case: the problem is that not all errors and states are created equal: 
quantum states live in a continuous space, so it is possible for some errors to corrupt a state by a tiny amount (or not at all), while others mess it up completely.
An example would be the bit flip error $X$ which does not affect $(\ket{0} + \ket{1}) / \sqrt{2}$ whereas it sends $\ket{0}$ to $\ket{1}$. 

To address this problem, we make use of the \emph{fidelity} \ref{def:fidelity} quantity. As seen above, the fidelity between a pure and a mixed state is given by 
$$ F(\ket{\psi}, \rho) = \sqrt{\braket{\psi | \rho | \psi}}$$
The goal of quantum error-correction is to increase the fidelity with which quantum information is stored (or communicated) near the maximum fidelity of one. 
We will compare the \emph{minimum} fidelity achieved by the three qubit flip code with the fidelity when no error correction is performed. 
\begin{itemize}
\item Suppose the quantum state of interest is $\ket{\psi}$. Without using the error correcting code, the state of the qubit after being sent through the channel is
$$ \rho = (1-p) \ket{\psi} \bra{\psi} + p X \ket{\psi} \bra{\psi} X$$ 
The fidelity becomes 
$$F = \sqrt{\braket{\psi | \rho | \psi}} = \sqrt{(1-p) + p \braket{\psi | X | \psi}^2}$$
Which is minimized when $\ket{\psi} = \ket{0}$ therefore at $F = \sqrt{1 - p}$. 

\item Now suppose that three qubit error-correcting code is used to protect the state $\ket{\psi} = a \ket{0_L} + b \ket{1_L}$. The quantum state after noise and error correction is 
$$\rho = [(1-p)^3 + 3p(1-p)^2] \ket{\psi} \bra{\psi} + \hat{\varepsilon}$$
Where $\hat{\varepsilon} \geq 0$ represents the contributions from bit flips on two or three qubits. Therefore a \emph{lower bound} on the true fidely is 
$$F = \sqrt{\braket{\psi | \rho | \psi}} \geq \sqrt{(1-p)^3 + 3p(1-p)^2}$$
\end{itemize}

\paragraph{Generalization} 
There is a different way of understand syndrome measurment that is useful in generalizing the three qubit code. Suppose that 
instead of measuring the four projectors $P_0, P_1, P_2, P_3$ we performed two measurments, the first of the observable $Z_1 Z_2$ ($Z \otimes Z \otimes I$) and the second of the observable $Z_2 Z_3$. 
Each of these have eigenvalues $\pm 1$ giving us ine bit of information each (four possible syndromes just as the earlier case). The first measurement, of $Z_1 Z_2$ compares if the first and second qubits are the same. 
To see this, note that $Z_1 Z_2$ has spectral decomposition 
$$Z_1 Z_2 = \left(\ket{00} \bra{00} + \ket{11} \bra{11}\right) \otimes I - \left(\ket{01} \bra{01} + \ket{10} \bra{10}\right) \otimes I$$
which corersponds to a projective measurment with projectors $\left(\ket{00} \bra{00} + \ket{11} \bra{11}\right) \otimes I$ and $\left(\ket{01} \bra{01} + \ket{10} \bra{10}\right) \otimes I$. 
Thus measuring in $Z_1 Z_2$ can be though of as comparing the values of the first and second qubits, and measuring in $Z_2 Z_3$ compares that of the second and third. Combining these two measurments results, we can determine whether a bit flip 
occured on one of the qubits, and if so which one. 

What is crucial to the success of these measurments is that neither of them gives any information about the amplitudes $a$ and $b$ of the encoded quantum state, this neither measurments destroys the superosition of quantum states that we wish to preserve using the code. 

\subsection{Three qubit phase flip code}
While the bit flip code is interesting, it does not appear to be a significant innovation over classical error-correcting codes, and leaves many other kinds of error untreated. 

\begin{definition}
A more intresting noisy quantum channel is the \emph{phase flip} error model for a single qubit. In tihs model the 
qubit is left untouched with probability $1-p$, and with probability $p$ the relative phase of the $\ket{0}$ and $\ket{1}$ states is flipped. 
More precisely, the phase flip operator $Z$ is applied iwth probability $p > 0$, so the state $a \ket{0} + b \ket{1}$ is taken to the state 
$a \ket{0} - b \ket{1}$ under the phase flip.
\end{definition}


Notice that there is no classical equivalent to the phase flip channel. However, there is an easy way to turn the phase flip channel into a bit flip channel. 
Suppose we work in the qubit basis $\ket{+}, \ket{-}$. With respect to this basis, the operator $Z$ takes $\ket{+}$ to $\ket{-}$ and vice versa, i.e it acts just like a bit flip 
channel with respect to the labels $+$ and $-$! Therefore we use $\ket{0_L} := \ket{+++}, \, \ket{1_L} := \ket{---}$ for protection against phase flip errors. All the operation needed for error correction 
(encoding, detection and recovery) are the same as for the bit flip channel but with respect to the $\ket{+}, \ket{-}$ basis instead of the $\ket{0}, \ket{1}$. This can be accomplished by appying the Hadamard gate (which is its own inverse) 
at appropriate points in the procedure (this is because $H$ allows us to go back and forth between the $\ket{0}, \ket{1}$ and $\ket{+}, \ket{-}$ basies).
More explictely: 
\begin{itemize}
\item \textbf{Encoding:} First we encode exactly as for the bit flip channel, then we apply $H$ to each qubit. 

\item \textbf{Error detection:} We apply the same projective measurments, but conjugated by $H$ gates 
$$P_j \to H^{\otimes^3} P_j H^{\otimes^3}$$
Equivalently we could measure the observables
$$H^{\otimes^3} Z_1 Z_2 H^{\otimes^3} = X_1 X_2 \text{ and } H^{\otimes^3} Z_2 Z_3 H^{\otimes^3} = X_2 X_3$$

\item \textbf{Error correction:} The recovery opreation is the $H$-conjugated recovery operation from the bit flip code. 
\end{itemize}

Obviously, this code for the phase flip channel has the same characteristics as the code for the bit flip channel (minimum fidelity, improvement over no-error correction, \dots). We say that these two channels are unitarily equivalent. 

\begin{definition}
We say that two channels are \emph{unitarily equivalent} if and only if there exists a unitary operator $U$ such that the action of one channel is the same as the other provided that the first channel 
is preceded by $U$ and followed by $U^\dagger$. There operations may be trivially incorporated into the econding and error-correction operations. 
\end{definition}

\subsection{The Shor code}
The \emph{Shor code} is simple quantum code which can protect against the effects of an \emph{arbitrary} error on a single qubit. 
The code is a combination of the three qubit phase flip and bit flip codes: 
\begin{itemize}
\item We first encode the qubit using the phase flip code 
$$\ket{0} \to \ket{+++}, \, \ket{1} \to \ket{---}$$

\item Next, we encode each of these qubits using the three qubit bit flip code: 
$$\ket{+} \to \left(\ket{000} + \ket{111}\right) / \sqrt{2}, \, \ket{-} \to \left(\ket{000} - \ket{111}\right) / \sqrt{2}$$
\end{itemize}
The result is a nince qubit code with codewords given by: 
\begin{align*}
\ket{0} &\to \ket{0_L} \equiv \frac{(\ket{000} + \ket{111}) (\ket{000} + \ket{111})(\ket{000} + \ket{111})}{2 \sqrt{2}} \\
\ket{1} &\to \ket{1_l} \equiv \frac{(\ket{000} - \ket{111}) (\ket{000} - \ket{111})(\ket{000} - \ket{111})}{2 \sqrt{2}}
\end{align*}

\begin{definition}
This method of encoding using a hierarchy of levels is known as \emph{concatenation}. It is a great trick for obtaining 
new code from old, but also to prove some important results about QEC. 
\end{definition}

\paragraph{Correcting bit flips}
The Shor code is able to protect agaisnt phase flip and bit flip errors on any qubit. To see this, supppose a bit flip occurs on the first qubit, 
as for the bit flip code, we measure $Z_1 Z_2$ and find that the first and second qubits are different. Next we compare the second and third qubit 
and find out that they are the same, therefore the first qubit must have been flipped, and recover the error by flipping again. We can similarly detect and recover 
a bit flip error on any of the $9$ bits of the code. 

\paragraph{Correcting phase flips}
We cope in a similar manner with phase flips on the qubits. Suppose a phase flips occurs on the first qubit, the first block then changes from $\ket{000} + \ket{111}$ 
to $\ket{000} - \ket{111}$, and vice versa (note that a phase flip on any of the first 3 qubits has this effect). Syndrome measurement (observable $M_1$) begins by comparing the sign of 
the first and secon blocks of three qubits, we will get that the signs of the first and second blocks are different. Then syndrome measurment (observable $M_2$) compares the signs of the second 
and third blocks, and find that these are the same. Therefore we recover by flipping the sign in the first block. 

The syndrome measurments to for detecting phase flip erros in the Shor code correspond to measuring the observables 
$$M_1 := X_1 X_2 \cdots X_6, \, M_2 := X_4 \cdots X_9$$

Moreover, to recover from a phase flip on any of the first three qubits, we may simply apply $Z_1 Z_2 Z_3$. 

\paragraph{Correcting against arbitrary errors} 
Now suppose that both bit and phase flip errors occur on the first qubit,  that is $Z_1 X_1$ is applied to that qubit. 
Then we can easily that the procedure for detecting a bit flip on the first qubit will detect the bit flip and correct it, and similarly for the
procedure for detecting a phase flip on the first block of three qubits. 

Indeed, the Shor code protects against much more than just bit and phase flip errors on a single qubit, it can protect agaisnt \emph{arbitrary} errors 
on a single qubit (Even errors like replacing a qubit with garbage)! Moreover, no additional work is required to protect against these kinds of errors, 
the procedure we just described works just fine. 

Notice that we are able to correct a \emph{continuum} of errors that may occur on a single qubit be correcting only an \emph{discrete} subset of those errors.
This discretization of the errors is central to why QEC woks, and should be regarded in contrast to classical error-correction where this discretization is impossible. 

\begin{proof} \label{thm:Shor-correcting-arbitrary-errors}
To simplify the analysis, suppose arbitrary noise is occuring on the first qubit only. We will describe 
the noise by a trace-preserving quantum operation $\mathcal{E}$. We will do this by expanding $\mathcal{E}$ in an operator-sum
representation with operation elements $\{E_i\}$. Supposing the state of the encoded qubit is $\ket{\psi} = \alpha \ket{0_L} + \beta \ket{1_L}$ before the noise acts, 
then after the effect of noise we get the state
$$\mathcal{E} \left(\ket{\psi} \bra{\psi}\right) = \sum_i E_i \ket{\psi} \bra{\psi} E_i^\dagger$$
We will focus on the effect of error correction on an arbitrary term in this sum $E_i \ket{\psi} \bra{\ket} E_i^\dagger$. 
As an opreator on the first qubit, $E_i$ may be expanded as a linear combination of $I, \, X_1, \, Z_2, \, X_1 Z_1$: 
$$E_i = e_{i0} I + e_{i1} X_1 + e_{i2} Z_1 + e_{i3} X_1 Z_1$$
Therefore the (un-normalized) quantum state $E_i \ket{psi}$ can be written as a superposion of four terms 
$\ket{\psi}, \, X_1 \ket{\psi},\, Z_1 \ket{\psi}, \, X_1 Z_1 \ket{\psi}$ from which recovery may be performed by applying approriate inversion operations, resulting in 
$\ket{\psi}$. 

Thus error correction results in the original state $\ket{\psi}$, despite the fact that error correction on the first qubit 
was arbitrary. Notice that by just correcting a discrete set of errorsL the bit flip, the phase flip and the combined bit-phase flip, a quantum-error 
correcting code is able to correct a continuous class of errors.
\end{proof}

If the noise is affecting more than just the first qubit, we have two basic ideas. If it is a good approximation to assume that noise 
acts  on all qubits, provided that the per-qubit error probability is low, we expand the effect of noise over terms involving 
errors on no qubit, one qubit, two qubits, etc. Performing error correction results on the zeroth and first order terms being corrected properly, 
and leaves only much smaller second and higher order error. 
If it is not reasonable to assume that noise acts independently, we use error-correcting code which can correct errors on more than a single qubit. 

\section{Theory of quantum error-correction} 
The basic ideas of the theory of quantum error-correction generalize in a natural way the ideas introduced by the Shor code. Quantum states are encoded 
by a unitary opreation into a \emph{quantum error-correcting code}, a subspace $C$ of some larger Hilbert space. We use the notation $P$ for the projector onto 
the code space $C$ (for the three qubit flip code $P = \ket{000} \bra{000} + \ket{111} \bra{111}$). After encoding the code is subjected to noise 
following which a syndrome measurement is performed to diagnose the type of error which occured, that is, the \emph{error syndrome}. 
Once this has been determined, a \emph{recovery} operation is performed, to return the system to the original state of the code: different error syndromes 
correspond to undeformed and orthogonal subspaces of the Hilbert space. 

To develop a general theory of QEC, we just make two very broad assumptions: 
\begin{enumerate}
\item the noise is described by a quantum operation $\mathcal{E}$. 
\item The complete error-correction procedure is effect by a trace preserving quantum operation $\mathcal{R}$, 
which we call the \emph{error-correction operation}. Note that it bundles into one piece error-detection and recovery.  
\end{enumerate}
In order for the error-correction to be successful, we require that for any state $\rho$ whose support lies in $C$, 
$$(\mathcal{R} \circ \mathcal{E}) (\rho) \propto \rho$$
Note that we are using $\propto$ instead of $=$ since we may be interested in error-correcting non-trace-preserving operations $\mathcal{E}$, such as measurments for which $\propto$ is appropriate. 

\paragraph{Quantum error-correction conditions} 
The \emph{quantum error-correction conditions} are a simple set of equations which can be checked to determine whether a quantum error correcting code protects against a particular type of noise $\mathcal{E}$. 

\begin{theorem}[Quantum error-correction conditions] \label{thm:quantum-error-correction-conditions}
Let $C$ be a quantum code, and $P$ be the projector onto $C$. Suppose $\mathcal{E}$ is a quantum opreation with operational elements 
$\{E_i\}$. There exists an error-correction opreation $\mathcal{R}$ correcting $\mathcal{E}$ on $C$ if an only if 
$$P E_i^\dagger E_j P = \alpha_{ij} P$$
for some Hermitial matrix $\alpha$ of complex numbers. 

We call the operation elements $\{E_i\}$ for the noise $\mathcal{E}$ \emph{errors}, and if such an $\mathcal{R}$ exists, 
we say that $\{E_i\}$ constitutes a \emph{correctable set of errors}.
\end{theorem}

\subsection{Discretization of the errors}
We have discussed the protection of quantum information against a specific noise process $\mathcal{E}$. In general, however, 
we don't know what noise is afflicting a quantum system. 

Ideally, we would have a code $C$ and error-correction operation $\mathcal{R}$ that could protect against a class of 
noise processes. We will adapt the quantum error-correction conditions for this type of protection. 

\begin{theorem}
Let $C$ be a quantum code and $\mathcal{R}$ be the error-correction operation constructed by Theorem \ref{thm:quantum-error-correction-conditions}
to recover a from noise process $\mathcal{E}$ with operational elements $\{E_i\}$. Suppose $\mathcal{F}$ is a quantum opreation with operation $\{F_j\}$ which 
are \emph{linear combinations} of the $E_i$ ($F_j = \sum_i m_{ji} E_i)$.  Then the error-correction operation $\mathcal{R}$ also corrects for the effects of the noise 
process $\mathcal{F}$ on the code $C$. 
\end{theorem}
This results enables the introduction of powerful language to describe quantum error-correcting codes. Instead of talking about 
the class of error process $\mathcal{E}$ correctable by a code $C$ and error-correction operation $\mathcal{R}$, we talk about a set of \emph{errors} $\{E_i\}$ which are correctable.
By this, we mean that the quantum error-correction conditions hold for these operators 
$$P E_i E_j^\dagger P = \alpha_{ij} P$$
Therefore, any noise process $\mathcal{E}$ whose operation elements are built from linear combinations of these error operators $\{E_i\}$ will be corrected 
by the recovery operation $\mathcal{R}$! 

\paragraph{Example} 
Suppose $\mathcal{E}$ is a quantum opreation acting on a single qubit. Then its operation elements $\{E_i\}$ can each be written as a linear 
combination of the Pauli matrices $\sigma_0, \sigma_1, \sigma_2, \sigma_3$. Therefore to check that a code corrects against \emph{arbitrary} single 
qubit errors on the first qubit, it is sufficient to verify that
$$P \sigma_i^1 \sigma_j^1 P = \alpha_{ij} P$$
This is why, the capacity to correct error from the depolarizing channel 
$$\mathcal{E}(\rho) = (1-p) \rho + \frac{p}{3} (X \rho X + Y \rho Y + Z \rho Z)$$
inplies the ability to error-correct an \emph{arbitrary} single qubit quantum operation. 

\subsection{The quantum Hamming bound} 

\begin{definition}
A code is said to be \emph{degenerate} if we have two different errors that have the same effect 
on codewords. 

A simple example is that of the Shor code where the errors $Z_1$ and $Z_2$ both flip the phase of the first block of the 
codewords of the Shor code. 
\end{definition}

Unfortunately, the \emph{quantum Hamming bound} only applies to non-degenerate codes, but it gives us an idea of what more general bounds 
may look like. Suppose a non-degenerate code is used to encode $k$ qubits in $n$ qubits in such a way that it can 
correct errors on any subset of $t$ or fewer qubits. Suppose that $j \leq t$ errors occur, there are $\binom{n}{j}$ sets of locations where errors may occur. 
With each such set of locations there are three possibl errors (the Pauli matrices $X, Y, Z$), for a total of $3^j$ possible errors. The total numbers of 
errors that may occur on $t$ or fewer qubits is therefore 
$$ \sum_{j = 0}^t \binom{n}{j} 3^j$$
In order to encode $k$ qubits in a non-degenerate way each of these errors must correspond to an orthogonal $2^k$-dimensional subspace. But all of these 
subspaces must be fitten into the total $2^n$-dimensional space available to $n$ qubits, leading the the inequality \ref{thm:quantum-hamming-bound}

\begin{theorem}[The quantum Hamming bound] \label{thm:quantum-hamming-bound}
Suppose we want to encode (non-degenerately) $k$ qubits, with a block size of $n$ qubits such that we can correct any subset of 
$j \leq t$ errors. Therefore the following inequality must hold 
$$\sum_{j = 0}^{t} \binom{n}{j} 3^j 2^k \leq 2^n$$ 
\end{theorem}

Of course, not all quantum codes are non-degenerate, so the quantum Hamming bound is more useful as a rule of thumb than as a hard 
bound on the existence of quantum codes (As of today, there are no known codes which violate the quantum Hamming bound). 

\section{Constructing quantum codes}

\subsection{Carlderbank-Shor-Steane codes}
CSS codes are an important subclass of the more general class of \emph{stabilizer} codes. 
\begin{definition}
Let $C_1$ and $C_2$ be $[n, k_1]$ and $[n, k_2]$ classical linear codes over $\mathbb{F}_2why $ such that $C_2 \subset C_1$ and $C_1$ and $C_2^\perp$ both correct 
$t$ errors. We define the \emph{CSS code of $C_1$ over $C_2$ $\operatorname{CSS}(C_1, C_2)$} to be an $[n, k_1 - k_2]$ quantum code capable of correcting errors on $t$ qubits via the following construction: \\
Let $x \in C_1$ be an arbitrary codeword in $C_1$, we define the quantum state $\ket{x + C_2}$ to be 
$$\ket{x + C_2} := \frac{1}{\sqrt{|C_2|}} \sum_{y \in C_2} \ket{x + y}$$
Let $x' \in C_1$ such that $x - x' \in C_2$, then clearly $\ket{x + C_2} = \ket{x' + C_2}$, therefore the state $\ket{x + C_2}$ depends only upon the coser $C_1 / C_2$ which $x$ is in. 
Moreover, if $x$ and $x'$ belong to different cosets of $C_2$, then for no $y, y' \in C_2$ does $x + y = x' + y'$, and therefore $\ket{x + C_2}$ and $\ket{x' + C_2}$ are orthonormal states. 

The quantum code $\operatorname{CSS}(C_1, C_2)$ is defined to be vector space spanned by the states $\ket{x + C_2}$ for all $x \in C_1$. 
The dimension of $\operatorname{CSS}(C_1, C_2)$ is $|C_1|/|C_2| = 2^{k_1 - k_2}$, and therefore $\operatorname{CSS}(C_1, C_2)$ is an 
$[n, k_1 - k_2]$ quantum code.

We can exploit the classical error-correcting properties of $C_1$ and $C_2^\perp$ to detect and correct quantum errors. 
In fact it is possible to correct and detect up to $t$ bit and phase flip errors on $\operatorname{CSS}(C_1, C_2)$ by making use 
of the properties of $C_1 $and $C_2^\perp$ respectively. 
\end{definition}

\paragraph{Correcting bit-flips}
Suppose the bit flip errors are described by an $n$ bit vector $e_1$ with $1$
where the bit flips occured, and the phase flip errors are described by an $n$ bit vector $e_2$ with $1$s where phase flips occured. 
If $\ket{x + C_2}$ was the original state then the corrupted state is 
$$\frac{1}{\sqrt{|C_2|}} \sum_{y \in C_2} (-1)^{(x + y) \cdot e_2} \ket{x + y + e_1}$$
To detect bit flips, it is convenient to introduce an ancilla containing sufficient qubits to store the syndrome for $C_1$, and initially the 
$\ket{0}$ state. We use reversible computation (CNOTS) to apply the parity matrix $H_1$ of $C_1$ taking 
$$\ket{x + y + e_1} \ket{0} \to \ket{x + y + 1} \ket{H_1 (x + y + e_1)} = \ket{x + y + e} \ket{H_1 e_1}$$
Therefore the effect of this operation is to produce the state: 
$$\frac{1}{\sqrt{|C_2|}} \sum_{y \in C_2} (-1)^{(x+y) \cdot e_2} \ket{x + y + e_1} \ket{H_1 e_1}$$
Error-detection for the bit flip errors is completed by measuring the anscilla to obtain $H_1 e_1$ and discarding the ancilla, giving the state 
$$\frac{1}{\sqrt{|C_2|}} \sum_{y \in C_2} (-1)^{(x+y) \cdot e_2} \ket{x + y + e_1}$$
Knowing $H_1 e_1$ we can infer $e_1$ since $C_1$ can correct up to $t$ errors, which completes the error-detection. Recovery is performed by 
applying NOT gates to the qubits at whichever positions in $e_1$ a bit flip occured, removing all the bit flip errors and giving the state
$$\frac{1}{\sqrt{|C_2|}} \sum_{y \in C_2} (-1)^{(x+y) \cdot e_2} \ket{x + y}$$

\paragraph{Correcting phase-flips}
To detect phase flip errors, we apply Hadamard gates to each qubit, taking the state to 
$$\frac{1}{\sqrt{|C_2| 2^n}} \sum_z \sum_{y \in C_2} (-1)^{(x+y) \cdot (e_2 + z)} \ket{z}$$
where the sum is over all possible values for $n$ bit $z$. Setting $z' = z + e_2$ we get 
$$\frac{1}{\sqrt{|C_2| 2^n}} \sum_{z'}\sum_{y \in C_2} (-1)^{(x+y) \cdot z'} \ket{z' + e_2}$$
But if $z' \in C_2^\perp$, then $\sum_{y \in C_2} (-1)^{y \cdot z'} = |C_2|$, and if $z' \not\in C_2^\perp$ then 
$\sum_{y \in C_2} (-1)^{y \cdot z'} = 0$ which gives us 
$$\frac{1}{\sqrt{2^n / |C_2|}} \sum_{z' \in C_2^\perp} (-1)^{x \cdot z'} \ket{z' + e_2}$$
Which is just a bit flip error described by the vector $e_2$. Therefore we can just error-detect as above, by introducing 
an ancilla and reversibly applying the parity check matrix $H_2$ for $C_2^\perp$ to obtain $H_2 e_2$, and correct $e_2$ obtaining the state
$$\frac{1}{\sqrt{2^n / |C_2|}} \sum_{z' \in C_2^\perp} (-1)^{x \cdot z'} \ket{z'}$$
The error correction is completed by again applying Hadamard gates to each qubits, obtaining 
$$\frac{1}{\sqrt{|C_2|}} \sum_{y \in C_2} \ket{x + y}$$
which is the original encoded state $\ket{x + C_2}$!

\paragraph{Summary} 
Let $C_1$ and $C_2$ be $[n, k_1]$ and $[n, k_2]$ classical linear codes such that $C_2 \subset C_1$, and both $C_1$ and $C_2^\perp$ can correct errors on up to $t$ bits. 
Then $\operatorname{CSS}(C_1, C_2)$ is a $[n, k_1 - k_2]$ quantum error-correcting code which can correct arbitrary errors on $t$ qubits. 
Furthermore, the error-detection and correction steps require only the application of Hadamard and CNOT gates, in each case a number linear in the size of the code. Encoding and decoding can also be performed in a linear number 
of gates in the code. 

\paragraph{Notation} 
The codes defined by 
$$\ket{x + C_2} := \frac{1}{\sqrt{|C_2|}} \sum_{y \in C_2} (-1)^{u \cdot y} \ket{x + y + v}$$
and parametrized by $u, v \in \mathbb{F}_2^n$ are \emph{equivalent} to $\operatorname{CSS}(C_1, C_2)$. 
We denote these code by $\operatorname{CSS}_{u, v}(C_1, C_2)$. 

\paragraph{The Steane code} This is an important example of a CSS code that may be constructed using the $[7, 4,3]$ Hamming code which has parity check matrix:
\[
H[C_1] = \begin{pmatrix}
1 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 1 & 1 & 0 & 0 & 1 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{pmatrix}
\]
Suppose we lavel this code $C_1$ and $C_2 = C_1^\perp$. To use these to define a CSSC code, we need to check that $C_2 \subset C_1$. 
But the parity check matrix of $C_2$ is the transpose of the generator matrix of $C_1$: 
\[
H[C_2] = G[C_1]^T =
\begin{pmatrix}
1 & 0 & 0 & 0 & 1 & 1 & 1\\
0 & 1 & 0 & 0 & 1 & 0 & 1\\
0 & 0 & 1 & 0 & 1 & 1 & 0\\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{pmatrix}
\]
Comparing the two, we see that the span of the rows of $H[C_2]$ contains the span of the rows of $H[C_1]$, 
and since the codes are the kernels of these parity check matrices, $C_2 \subset C_1$. Moreover $C_2^\perp = C_1$, so $C_1$ and $C_2^\perp$ 
are both distance $3$ codes which can correct errors on $1$ bit. 
Furthermore, since $C_1$ is a $[7, 4]$ code and $C_2$ is a $[7,3]$ code it follows that $\operatorname{CSS}(C_1, C_2)$ is a $[7,1]$ quantum code 
which can correct errors on a single qubit. 

\begin{definition}
    We define this $[7,1]$ quantum code to be the \emph{Steane code}.
\end{definition}

This code has nice properties that make it easy to work with, notice that 
\begin{align}
    \ket{0_L} &= \ket{0 + C_2} \\
    &= \frac{1}{\sqrt{8}} \big[
        \ket{0000000} + \ket{1010101} + \ket{0110011} + 
        \ket{1100110} + \\
        &\quad \ket{0001111} + \ket{1011010} + 
        \ket{0111100} + \ket{1101001}
    \big] 
\end{align}
To determine $\ket{1_L}$ we need to find an element of $C_1$ that is not in $C_2$, such as $\ket{1111111}$ giving: 
\begin{align}
    \ket{1_l} &= \frac{1}{\sqrt{8}} \big[ 
        \ket{1111111} + \ket{0101010} + \ket{1001100} + 
        \ket{0011001} \\
        &\quad + \ket{1110000} + \ket{0100101} + \ket{1000011} + \ket{0010110} 
    \big]
\end{align}

\subsection{Quantum Gilbert-Varshamov bound} 
One important application of CSS codes is the proof of the \emph{quantum Gilbert–Varshamov bound}.  Fix any \(\delta\in(0,1)\) and set 
\[
t = \frac{\delta n}{2}\,.
\]
Then in the asymptotic regime \(n\to\infty\) there exist \([n,k]\) CSS codes correcting up to \(t\) qubit-errors whose rate satisfies
\[
\frac{k}{n}
\;\ge\;
1 \;-\; 2\,H(\delta)
\;-\;
O\!\Bigl(\tfrac{\log n}{n}\Bigr),
\]
or equivalently
\[
\frac{k}{n}
=
1 \;-\; 2\,H\!\Bigl(\tfrac{2t}{n}\Bigr)
\;-\;
o(1).
\]
Here 
\[
H(x) \;=\; -\,x\log_{2}x \;-\;(1-x)\log_{2}(1-x)
\] 
And Thus, good quantum error-correcting codes exist, provided we don't pack too many qubits $k$ into an $n$ qubit code. 

\section{Stabilizer codes} 
\emph{Stabilizer} (or \emph{additive}) quantum codes, are a class of quantum whose construction is similar to that of classical 
linear codes. In order to understand stabilizer codes it is useful to first develop the \emph{stabilizer formalism}, 
a powerful method for understanding a wide class of operations in quantum mechanics. 

\subsection{The stabilizer formalism} 
The central insight of the stabilizer formalism is easily illustrated by an example. Consider an EPR pair 
$$\ket{\psi} = \frac{\ket{00} + \ket{11}}{\sqrt{2}}$$
It is easy to verify that $X_1 X_2 \ket{\psi} = \ket{\psi}$ and that $Z_1 Z_2 \ket{\psi} = \ket{\psi}$; we say that the 
state $\ket{\psi}$ is \emph{stabilized} by the operators $X_1 X_2$ and $Z_1 Z_2$. Less obviously, 
the state $\ket{\psi}$ is the unique quantum state (up to global phase) which is stabilized by thesse operators. 

The basic idea of the stabilizer formalism is that many quantum states are easily described by working with the operators 
that stabilize them. It turns out that many quantum codes (including CSS codes and the Shor code) can be much more compactly described 
using the stabilizers than the state vector description. Even more importantly, errors on the qubits / operations
(such as Hadamard gate, phase gate, CNOT gate) and measurement in the computational basis are all easily desxribed using the 
stabilizer formalism. 

\begin{definition}
    The general \emph{Pauli Group} $G_n$ on $n$ qubits is the group consisting of all $n$-fold tensor 
    products of the Pauli matrices, together with multiplicative factors of $\pm 1, \pm i$.

    Notice that for a single qubit, the Pauli group is 
    $$G_1 := \{\pm I, \pm i I, \pm X, \pm i X, \pm Y, \pm iY, \pm Z, \pm iZ\}$$
\end{definition}

\begin{definition}
    Let $S$ be a subgroup of $G_n$, and define $V_S$ to be the set of 
    $n$ qubit states which are fixed by $S$. Then $V_S$ is the \emph{vector space staibilized by S} and $S$ is said 
    to be the stabilizer of the space $V_S$. 

    Equivalently, given $S \subset G_n$, the codespace stabilized by $S$ is 
    $$C = \{\ket{\psi} \in (\mathbb{C}^2)^{\otimes n} \mid \ g \ket{\psi} = \ket{\psi} \quad \forall g \in S\}$$
    or given a codespace $C$, its stabilizer is 
    $$\operatorname{Stab}(C) = \{g \in P_n \mid \ g \ket{\psi} = \ket{\psi} \quad \forall \psi \in C\}$$
\end{definition}

Note that to check that a vector is stabilizer by a group $S$ we only need to check that 
it is stabilized by its \emph{generators}. Which gives us a very compact way of determining $V_S$. 

Some subgroups $S$ of the Pauli groups can't be used to stabilize a non-trivial vector space. 
For example, consider the subgroup $G_1$ consisting of $\{\pm I, \pm X\}$. Obviously the only solution to 
$$(-I) \ket{\psi} = \ket{\psi} \text{ is } \ket{\psi} = 0$$
and therefore $G_1$ stabilizes the trivial vector space. For $S$ to stabilize a 
non-trivial vector space if and only if the following two conditions hold
\begin{enumerate}[label = (\alph*)]
    \item The elements of $S$ commute
    \item $-I \not\in S$ 
\end{enumerate}

A nice example of the stabilizer formalism is provided by the seven qubit Steane code 
It turns out that the six generators $g_1, \cdots, g_6$ listed in the Table \ref{tab:generators-Steane} generate a stabilizer code for 
the code space of the steane code. Note the similarity in structure between the generators in Table \ref{tab:generators-Steane} and the 
parity check matrices for $C_1$ and $C_2^\perp$ used in the construction of the Steane code. 
The first three generators of the stabilizer have $X$s in locations corresponding to the locations of the $1$s in the parity 
check matrix for $ C_1$, while the final three generators have $Z$s in locations corresponding to the locations 
of the $1$s in the parity check matrix for $C_2^\perp$.  

\begin{table}[ht]
  \centering
  \begin{tabular}{@{} c l @{}}
    \toprule
    \textbf{Name} & \textbf{Operator} \\
    \midrule
    $g_1$ & $I\ I \ I \ X \ X\ X\ X$ \\
    $g_2$ & $I\ X\ X\ I\ I\,X\,X$ \\
    $g_3$ & $X\ I\ X\ I\ X\ I\ X$ \\
    $g_4$ & $I\ I\ I\ Z\ Z\ Z\ Z$ \\
    $g_5$ & $I\ Z\ Z\ I\ I\ Z\ Z$ \\
    $g_6$ & $Z\ I\ Z\ I\ Z\ I\ Z$ \\
    \bottomrule
  \end{tabular}
  \caption{Generators of the Steane code}\label{tab:generators-Steane}
\end{table}

\paragraph{Independent generators}
In practice, we want our generators $g_1, \cdots, g_l$ to be \emph{independent}, in the sense that 
removing any generator $g_i$ makes the generator group smaller. 
Determining whether a particular set of generators is independent is time consuming, fortunately 
there is a simple way this can be done based on an idea known as the \emph{check matrix}.

\begin{definition}
    Let $S = \langle g_1, \cdots, g_l \rangle$, then the \emph{check matrix} is a useful way of presenting the 
    generators $g_1, \cdots, g_l$ of $S$. 
    This is an $l \times 2n$ matrix whose rows correspond to the generators $g_1$ through $g_l$; 
    the left hand side of the matrix contains $1$s to indicate which generators contain $X$s and the right hand side 
    indicates $Z$s; the presence of a $1$ on both sides indicates a $Y$ in the generator.
\end{definition}

We denote by $r(g)$ the $2n$-dimensional row vector representation of an element $g$ of the Pauli group, 
we also define a $2n \times 2n$ matrix $\Lambda$ by 
$$ \Lambda = \begin{pmatrix}
    0 & I_n \\
    I_n & 0
\end{pmatrix}$$ 
Elements $g$ and $g'$ of the Pauli group are easily seen to commute if and only if $r(g) \Lambda r(g')^T = 0$; 
the formula $x \Lambda y^T$ is a sort of twisted inner product between row matrices $x$ and $y$ expressing whether the elements 
corresponding to $x$ and $y$ commute or not. 

\begin{proposition}
    Let $S = \langle g_1, \cdots, g_l\rangle$ be such that $-I$ is not an element of $S$. 
    The generators $g_1, \cdots, g_l$ are independent if and only if the rows of the 
    corresponding parity check matrix are linearly independent. 
\end{proposition}

\begin{proposition}
    Let $S = \langle g_1, \cdots, g_l\rangle$ be generated by $l$ independent generators and satisfy $-I \not\in S$. 
    Let $i \in \{1, \cdots, l\}$, then there exists $g \in G_n$ such that 
    $$g g_i g^\dagger = - g_i$$
    and for all $j \neq i$ 
    $$g g_j g^\dagger = g_j$$
\end{proposition}

\begin{proposition}
    Let $S = \langle g_1, \cdots, g_{n-k}\rangle$ be generated by $n -k$ independant and commuting elements 
    from $G_n$ such that $-I \not\in S$. Then $V_S$ is a $2^k$-dimensional vector space. 
\end{proposition}

\subsection{Unitary gates and the stabilizer formalism} 
So far, we have used stabilizers to describe vector spaces. The formalism 
can also be used to describe the \emph{dynamics} of those vector spaces  in 
the larger state space under a variety of quantum operations. 
This is especially useful to desribe quantum error-correcting codes using stabilizers, and would like to have 
an elegant means for understanding the effects of noise and dynamical processes on those codes. 

Suppose we apply some unitary $U$ to a vector space $V_S$ stabilized by the group $S$. Let $\ket{\psi}$ be an element of $V_S$, 
then for any element $g \in S$, 
$$U \ket{\psi} = U g \ket{\psi} = U g U^\dagger U \ket{\psi}$$
and therefore $U \ket{\psi}$ is stabilizer by $U g U^\dagger$, hence $U V_S$ is stabilized by the group 
$$USU^\dagger = \{U g U^\dagger \mid g \in S\}$$ 
Furthermore, if $g_1, \cdots, g_l$ generate $S$, then $U g_1 U^\dagger, \cdots, U g_l U^\dagger$ generate $U S U^\dagger$, 
so to compute the change in stabilizer we only need to compute how it affects its generators. 

This is especially useful since for certain operations $U$, this transformation is really simple, for example 
$$H X H^\dagger = Z; \; HYH^\dagger = -Y; HZH^\dagger = X$$
So if a Hadamard is applied to the quantum state stabilized by $Z$ ($\ket{0}$), the resulting image will be stabilized by $X$ ($\ket{+}$). 

What is remarkable here is that the state vector description of the final state requires $2^n$ amplitudes to be specified, compared 
to $O(n)$ generators of the stabilizer group $\langle X_1, \cdots, X_n\rangle$. 
Similarly, the stabilizer formalism can give us efficient description of more complicated gates, such as the CNOT (which along with $H$ can create 
entanglement). To understand how this work consider the effects of conjugation by CNOT ($U$ gate): 
\begin{align}
    U X_1 U^\dagger &= X_1 X_2 \\
    U X_2 U^\dagger &= X_2 \\
    U Z_1 U^\dagger &= Z_1 \\
    U Z_2 U^\dagger &= Z_1 Z_2 
\end{align}
This and other useful conjugations are nicely summarized in Table \ref{tab:conjugation-table} below. 

\begin{table}[ht] \label{tab:conjugation-table}
  \centering
  \begin{tabular}{|c|c|c|}
    \hline\hline
    \textbf{Operation} & \textbf{Input} & \textbf{Output} \\
    \hline
    \multirow{CNOT}
      & $X_1$ & $X_1X_2$ \\
      & $X_2$ & $X_2$    \\
      & $Z_1$ & $Z_1$    \\
      & $Z_2$ & $Z_1Z_2$ \\
      & $Y_1$ & $Y_1 X_2$ \\
    \hline
    \multirow{$H$}
      & $X$ & $Z$ \\
      & $Z$ & $X$ \\
    \hline
    \multirow{$S$}
      & $X$ & $Y$ \\
      & $Z$ & $Z$ \\
    \hline
    \multirow{$X$}
      & $X$  & $X$  \\
      & $Z$  & $-Z$ \\
    \hline
    \multirow{$Y$}
      & $X$  & $-X$ \\
      & $Z$  & $-Z$ \\
    \hline
    \multirow{$Z$}
      & $X$  & $-X$ \\
      & $Z$  & $Z$  \\
    \hline\hline
  \end{tabular}
\end{table}

This is useful since it allows us to describe the effects of a circuit on $n$-qubits only by observing its effect on $\{Z_1 X_1, \cdots, Z_n, X_n\}$. 
This also implies the ability of the stabilizer formalism to describe certain types of quantum entanglement. 

Other than the Hadamard and the CNOT gate, the most important gate that can be described using stabilizers is the gate 
$$ S = \begin{pmatrix}
  1 & 0 \\ 0 & i
\end{pmatrix}$$ 
Which respects 
$$ SXS^\dager = Y; \quad SZS^\dagger = Z$$

\begin{definition}
  We define the set of $U$ such that $U G_n U^\dagger = G_n$ to be the \emph{normalizer} of 
  $G_n$, denoted by $\operatorname{N}(G_n)$.
\end{definition}

\begin{theorem}
  For any $n$, the normalizer of the $n$-qubit Pauli group 
  $$N(G_n) = \{U \in U(2^n) \mid U P U^\dagger \in G_n \ \forall P \in G_n\}$$
  is generated by Hadamard $H$, phase $S$ and CNOT gates, with an $O(n^2)$-size circuit. 
\end{theorem}

As useful as the normalizer $N(G_n)$ is, most quantum gates are outside it. Two gates of particular 
interest which aren't in the normalizer are the $\pi / 8$ and the Toffoli gates. 
Unfortunately, this makes analyzing quantum circuits including $\pi / 8$ and Toffoli gates via the stabilizer 
formalism much less convenient than circuits which only contain $H$, $S$ and CNOT gates. 
Fortunately, encoding, decoding, and error-recovery (detection + recovery) for stabilizer quantum codes can be 
accomplished using only normalizer gates, so the stabilizer formalism stays relevant for the analysis of these codes. 

\subsection{Measurment in the stabilizer formalism} 
Measurment in the computational basis may also be easily described within the stabilizer formalism. 
To understand how this works, imagine we make a measurment of $g \in G_n$ ($g$ is Hermitian).
For convenience, we assume wlog that $G$ is a product of Pauli matrices with no multiplicative factor. 
The system is assumed to be in a state $\ket{\psi}$ stabilized by $\langle g_1, \cdots, g_n\rangle$. Then 
\begin{enumerate}
  \item $G$ commutes with all the generators of the stabilizer. Therefore either $g$ or $-g$ is in the stabilizer. Assume wlog that $g \in \operatorname{Stab}$, hence 
  $$ g \ket{\psi} = \psi$$
  so the measurment yields $+1$ with probability one and thus leaves the stabilizer invariant. 

  \item $g$ anti-commutes with at least one of the generators, wlog $g_1$ and wlog it commutes with $g_2, \cdots, g_n$. In this case, 
  the prjoectors for the measurment outcomes $\pm 1$ are given by $(I \pm g) / 2$ (respectively), it can be show that 
  $$p(+1) = p(-1) = 1/2$$
  If the result $+1$ occurs, the new state of the system is 
  $$\ket{\psi^+} = (I + g) \ket{\psi} / \sqrt{2}$$
  with stabilizer $\langle g, g_2, \cdots, g_n\rangle$. Similarly if $-1$ occurs the state is stabilized by 
  $\langle - g, g_2, \cdots, g_n \rangle$. 
\end{enumerate}

\subsection{The Gottesman-Knill theorem} 

\begin{theorem}[Gottesman-Knill theorem]\label{thm:Gottesman-Knill}
    Any quantum computation on $n$ qubits that 
    \begin{enumerate}
      \item starts in a stabilizer state ($U \ket{\psi} ^{\otimes n}$ where $U$ is a clifford unitary)
      \item uses only Clifford-group operations (Hadamard, phase, CNOT gates) 
      \item Measures observables in the Pauli group (which includes in measurment in the computational basis) 
    \end{enumerate}
    Can be simulated efficiently on a classical computer, in time polynomial in $n$ and the number of gates.
\end{theorem} 

The way the classical simulation works is simply by keeping track of the generators of the stabilizer as the circuit is applied. 
We simply update each of the $n$ generators describing the quantum state. Pauli gates, and measurements of the observables in 
the Pauli group may all be simulated in $O(n^2)$ steps on a classical computer, so a quantum computation involving $m$ operations 
from this set can be simulated in $O(m n^2)$ operations on a classical computer.

\paragraph{Applications} Although not all quantum computations (and therefore entanglements) 
can be efficeintly described within the stabilizer formalism, consider that tasks such as 
quantum teleportation, and super-dense coding can be performed using only the $H$ and CNOT gate and 
measurments in the computational basis, therefore they can be efficiently simulated on a classical computer. 
Moreover, a wide variety of quantum error-correcting codes can be described within the stabilzier formalism. 

\subsection{Stabilizer code constructions} 
The stabilizer formalism is ideal for the description of quantum codes. 
\begin{definition}
  We define an $[n,k]$ \emph{stabilizer code} to be the vector space $V_S$ stabilized by a subgroup $S$ of $G_n$ such that 
  $-I \not\in S$ and $S$ is generated by $n - k$ independent generators. 
  $$S = \langle g_1, \cdots, g_{n-k}\rangle$$
  We denote this code $C(S)$.  
\end{definition}

In principle, given $n-k$  independent generators we can choose any $2^k$ orthonormal vectors in $C(S)$ to act 
as our logical computational basis states. In practice, we want to chose these states in a more systematic way. One example 
is: 
\begin{enumerate}
  \item We chose operators $\overline{Z_1}, \cdots, \overline{Z_k} \in G_n$ such that
  $$\{g_1, \cdots, g_{n-k}, \overline{Z_1}, \cdots, \overline{Z_k} \}$$ 
  forms an independent and commuting set. The $\overline{Z_j}$ operator plays the role of a logical Pauli $\sigma_z$ operator on 
  logical qubit $j$, so the logical basis state $\ket{x_1 \cdots x_k}_L$ is therefore defined to be the state with stabilizer 
  $$\langle g_1, \cdots, g_{n-k}, (-1)^{x_1}\overline{Z_1}, \cdots, (-1)^{x_k} \overline{Z_k}\rangle$$ 

  \item Similarly, we define $\overline{X_j}$ to be that the product of Pauli matrices which takes $\overline{Z_j}$ to 
  $- \overline{Z_j}$ under conjugation, and leaves all other $\overline{Z_i}$ and $g_i$ alone when acting by conjugation. i.e 
    \[
  \begin{aligned}
  \overline X_j \,\overline Z_j \,\overline X_j^\dagger &= -\,\overline Z_j,\\
  \overline X_j \,\overline Z_i \,\overline X_j^\dagger &= \overline Z_i
    \quad\text{for }i\neq j,\\
  \overline X_j \,g_k\,\overline X_j^\dagger &= g_k
    \quad\text{for all stabilizer generators }g_k.
  \end{aligned}
  \]
  Clearly $\overline{X_j}$ has the effect of flipping the logical $j$th qubit, and commutes with all the generators of the 
  stabilizer. 
\end{enumerate}

In the three following paragraphs, let $C(S)$ be an $[n,k]$ stabilizer code with stabilizer $S = \langle g_1, \cdots, g_{n-k}\rangle$. 

\paragraph{Types of error} Suppose $C(S)$ is corrupted by an error $E \in G_n$. 
\begin{itemize}
  \item If $E \in S$, then we don't worry, since the 'error' $E$ doesn't corrupt the space at all. 

  \item If $E$ anti-commutes with an element of the stabilizer, 
  $E$ takes $C(S)$ to an orthogonal subspace, and the error can be detected (and corrected) by 
  performing a projective measurment.

  \item The real danger is when $E$ commutes with all elements of $S$ but $E \not\in S$, i.e 
  $$Eg = gE \quad \forall g \in S$$
  In this case, we say that $E \in Z(S) = \{E \in S \mid Eg = gE \quad \forall g \in G_n\}$ the \emph{centralizer} of $S$ in $G_n$ 
  In fact, for the stabilizer group $S$ (that doesn't contain $-I$), the centralizer is identical to the normalizer
  $$N(S) = \{E \in G_n \mid EgE^\dagger \in S \quad \forall g \in S\}$$
\end{itemize} 

\paragraph{Error-correction conditions for stabilizer codes} The following theorem is simply a translation of
the quantum error-correcting conditions (Theorem \ref{thm:quantum-error-correction-conditions}) into the terms 
of stabilizer formalism. 

\begin{theorem}[Error-correction conditions for stabilizer codes]\label{thm:conditions-stabilizer-codes} 
  Let $S$ be a stabilizer for a code $C(S)$. Suppose $\{E_j\}$ is a set of operators in $G_n$ 
  such that $E_j ^\dagger E_k \not \in N(S) \setminus S$ for all $j$ and $k$. then $\{E_j\}$ 
  is a correctable set of errors for $C(S)$.   
\end{theorem}
Wlog, we can only consider the case where $E_j$ are errors in $G_n$ such that $E_j ^\dagger = E_j$, which reduces the condition to 
$$E_j E_k \not\in N(S) \setminus S \quad \forall j, k$$

\paragraph{Error-detection and recovery} Theorem \ref{thm:conditions-stabilizer-codes} is a wonderful theoretical result 
but doesn't give us insight on how to perform error-correction when it is possible. 
Let \(\{g_1,\dots,g_{n-k}\}\) be independent generators of the stabilizer \(S\) for an \([n,k]\) code, and let \(\{E_j\}\) be the set of correctable errors.

\begin{enumerate}
  \item \textbf{Syndrome measurement.}
    \begin{itemize}
      \item Measure each \(g_\ell\) on the corrupted state.
      \item Record outcomes \(\beta_\ell\in\{+1,-1\}\) defined by
      \[
        E_j\,g_\ell\,E_j^\dagger = \beta_\ell\,g_\ell.
      \]
      \item The \emph{syndrome} is the vector \(\bigl(\beta_1,\dots,\beta_{n-k}\bigr)\).
    \end{itemize}

  \item \textbf{Unique‐syndrome recovery.}
    \begin{itemize}
      \item If \(E_j\) is the only operator yielding syndrome \(\beta\), recover by applying
      \[
        E_j^\dagger.
      \]
    \end{itemize}

  \item \textbf{Shared‐syndrome errors.}
    \begin{itemize}
      \item Suppose \(E_j\) and \(E_{j'}\) produce the same syndrome.  Then
      \[
        E_j\,P\,E_j^\dagger = E_{j'}\,P\,E_{j'}^\dagger
        \quad\Longrightarrow\quad
        \bigl(E_j^\dagger E_{j'}\bigr)\,P\,\bigl(E_j^\dagger E_{j'}\bigr)^\dagger = P.
      \]
      \item Hence \(E_j^\dagger E_{j'}\in S\).  Applying \(E_j^\dagger\) after \(E_{j'}\) has the same net effect as a stabilizer, which fixes the code.
    \end{itemize}
\end{enumerate}
Thus, for each possible error syndrome, we pick out a single error $E_j$ with that syndrome, 
and apply $E_j^\dagger$ to recover when that syndrome is observed. 

\subsection{Distance of a quantum code}
Theorem \ref{thm:conditions-stabilizer-codes} gives us a notion of \emph{distance} for a quantum code 
analogous to the distance of classical codes. 

\begin{definition}
  We define the \emph{weight} of an erorr $E \in G_n$ to be the number of non-identity 
  terms in the tensor product representation of $E$. 
\end{definition}

\begin{definition}
  The \emph{distance} of an $[n,k]$ stabilizer code $C(S)$ is defined to be the minimum weight of an element of 
  $N(S) \setminus S$, we say that $C(S)$ is an $[n,k,d]$ stabilizer code.   
\end{definition}

\begin{proposition}
  By Theorem \ref{thm:conditions-stabilizer-codes}, a code with distance at least $2t + 1$ can correct arbitary 
  errors on $t$ qubits. Moreover, we can correct any set of arbitrary $d-1$ located errors. 
\end{proposition}

\subsection{Examples} 
In all cases, the properties of the code follow easily by applying Theorem \ref{thm:conditions-stabilizer-codes} to the 
generators of the stabilizer. 

\paragraph{The three qubit bit/phase flip code}
Consider the three qubit bit flip code spanned by the states 
$\ket{000}$ and $\ket{111}$, with stabilizer generated by $Z_1 Z_2$ and $Z_2 Z_3$. 
It is easy to notice that every possible product of two elements from the error set $\{I, X_1, X_2, X_3\}$ 
anti-commutes with at least one of the generators of the stabilizer (except for $I \in S$), 
and thus by Theorem \ref{thm:conditions-stabilizer-codes} the set $\{I, X_1, X_2, X_3\}$ forms a correctable set of 
errors for the three qubit flip code with stabilizer $\langle Z_1 Z_2, Z_2 Z_3\rangle$. 

Similarly, the stabilizer for the three qubit phase flip code is generated by $X_1 X_2$ and $X_2 X_3$. 

\paragraph{The nine qubit Shor code} 
The stabilizer for the Shor code has eight generators, namely those illustrated in Table \ref{tab:generators-Shor}.

\begin{table}[h]
\centering
\begin{tabular}{@{}c c@{}}
\toprule
Name & Operator \\
\midrule
$g_{1}$ & $Z\,Z\,I\,I\,I\,I\,I\,I\,I$ \\
$g_{2}$ & $I\,Z\,Z\,I\,I\,I\,I\,I\,I$ \\
$g_{3}$ & $I\,I\,I\,Z\,Z\,I\,I\,I\,I$ \\
$g_{4}$ & $I\,I\,I\,I\,Z\,Z\,I\,I\,I$ \\
$g_{5}$ & $I\,I\,I\,I\,I\,I\,Z\,Z\,I$ \\
$g_{6}$ & $I\,I\,I\,I\,I\,I\,I\,Z\,Z$ \\
$g_{7}$ & $X\,X\,X\,X\,X\,X\,I\,I\,I$ \\
$g_{8}$ & $I\,I\,I\,X\,X\,X\,X\,X\,X$ \\
$\overline Z$ & $X\,X\,X\,X\,X\,X\,X\,X\,X$ \\
$\overline X$ & $Z\,Z\,Z\,Z\,Z\,Z\,Z\,Z\,Z$ \\
\bottomrule
\end{tabular}
\caption{Stabilizer generators and logical operators for the nine-qubit Shor code}
\label{tab:generators-Shor}
\end{table}
Also note that the logical $X$ and $Z$ operators could be flipped, but this would mean we would have to define our logical 
basis accordingly. 

\paragraph{The five qubit code} 
The minimum size for a quantum code which protects any arbitrary error on a single qubit 
is five qubits, its generators are given in Table \ref{tab:generators-five-qubit}. 

\begin{table}[h]
\centering
\begin{tabular}{@{}c c@{}}
\toprule
Name & Operator \\
\midrule
$g_{1}$ & $X\,Z\,Z\,X\,I$ \\
$g_{2}$ & $I\,X\,Z\,Z\,X$ \\
$g_{3}$ & $X\,I\,X\,Z\,Z$ \\
$g_{4}$ & $Z\,X\,I\,X\,Z$ \\
$\overline Z$ & $Z\,Z\,Z\,Z\,Z$ \\
$\overline X$ & $X\,X\,X\,X\,X$ \\
\bottomrule
\end{tabular}
\caption{Stabilizer generators and logical operators for the nine-qubit Shor code}
\label{tab:generators-five-qubit}
\end{table}

Which has as logical codewords 
\begin{align}
\lvert0_L\rangle &= \frac{1}{4}\Bigl[
   \lvert00000\rangle + \lvert10010\rangle + \lvert01001\rangle + \lvert10100\rangle
   + \lvert01010\rangle - \lvert11011\rangle - \lvert00110\rangle - \lvert11000\rangle\notag\\
 &\quad\;\;\;
   -\,\lvert11101\rangle - \lvert00011\rangle - \lvert11110\rangle - \lvert01111\rangle
   - \lvert10001\rangle - \lvert01100\rangle - \lvert10111\rangle + \lvert00101\rangle
\Bigr],\\
\lvert1_L\rangle &= \frac{1}{4}\Bigl[
   \lvert11111\rangle + \lvert01101\rangle + \lvert10110\rangle + \lvert01011\rangle
   + \lvert10101\rangle - \lvert00100\rangle - \lvert11001\rangle - \lvert00111\rangle\notag\\
 &\quad\;\;\;
   -\,\lvert00010\rangle - \lvert11100\rangle - \lvert00001\rangle - \lvert10000\rangle
   - \lvert01110\rangle - \lvert10011\rangle - \lvert01000\rangle + \lvert11010\rangle
\Bigr].
\end{align}
Note that the five qubit code saturates the quantum Hamming bound. 

\paragraph{CSS codes and the Steane code} 
The CSS codes are an excellent example of a class of stabilizer codes. Let $C_1$ and $C_2$ be 
$[n,k_1]$ and $[n,k_2]$ classical codes such that $C_2 \subset C_1$ and $C_1$ and $C_2^\perp$ both 
correct $t$ errors. Define a check matrix of the form 
$$\begin{pmatrix}
  H(C_2^\perp) & 0 \\
  0 & H(C_2)
\end{pmatrix}$$
To see that this defines a stabilizer code, we need to check the matrix to satisfy the commutativity 
condition $H(C_2^\perp) H(C_1)^T = 0$. But we have that 
\begin{align}
  H(C_2^\perp) H(C_1)^T &= [H(C_1)G(C_2^\perp)]^T \\
  &= 0 \quad \text{since $C_2 \subset C_1$}
\end{align}
Indeed, this code is exactly $\operatorname{CSS}(C_1, C_2)$, and it is capable of correcting arbitrary errors on $t$ qubits. 

The Steane code is an example of a CSS code with generators in Table \ref{tab:generators-Steane}. Encoded $Z$ and $X$ operators 
may be defined as 
$$\overline{Z} = Z^{\otimes 7}; \; \overline{X} = X^{\otimes 7}$$


\subsection{Standard form of a stabilizer code} 
The construction of logical $Z$ and $X$ operators for a stabilizer code is made much easier to understand if we 
put the code in \emph{standard form}. Consider the $n-k \times 2n$ check matrix of an $[n,k]$ stabilizer code $C$: 
$$G = \begin{pmatrix}
  G_1 & G_2
\end{pmatrix}$$ 
Swapping rows of this matrix corresponds to relabeling generators, swapping corresponding columns 
on both sides correspomds to relabeling qubits, adding two rows corresponds to relabeling generators. 
Notice that we can always replace $g_i$ by $g_i g_j$ for $j \neq i$. 

\begin{definition}
  We say that a code with check matrix of the form 
  \[
  
    \begin{array}{r}
      r \left\{ \right. &\\[1ex]
      n - k - r \left\{ \right.&
    \end{array}
  \;\;
  \left[
    \begin{array}{@{}ccc|ccc@{}}
      \overbrace{I}^{r} 
        & \overbrace{A_{1}}^{\,n-k-r} 
        & \overbrace{A_{2}}^{\,k}
      & \overbrace{B}^{r} 
        & \overbrace{0}^{\,n-k-r} 
        & \overbrace{C}^{\,k} \\[1ex]
      0 & 0 & 0 & D & I & E
    \end{array}
  \right],
  \]
  is in standard form. 

  It can be shown that any stabilizer code is equivalent to a code in this form. 
\end{definition}

Given the standard form for a quantum code, it is easy to define encoded $Z$ 
operations for the code. Suppose we write the check matrix for these $k$ encoded $Z$ operators 
in the form
$$G_z \left[F_1 F_2 F_3 \mid F_4 F_5 F_6\right]$$
where all the matrices have $k$ rows and $r, n-k-r, r, r, n-k-r, r$ columns respectively. Choose these such that 
$$G_z = \left[000 \mid A_2^T 0 I\right]$$
It is clear that the encded $Z$ operators commute with the elements of the stabilizer, and with one another 
(since they only contain $Z$ operators).
Moreover, these $\overline{Z}$ operators are indepedent from the first $r$ rows since they don't 
contain $X$ terms, and they're indepedent from the last $n-k-r$ generators because of the 
$I_{n-k-r}$ appearing in the check matrix of those generators. 

Similarly, we pick the encoded $X$ operators with the $k \times 2n$ check matrix 
$$G_x = \left[0 E^T I \mid C^T 0 0\right]$$
which are independent of one another, of the generators and of the $\overline{Z}$, commute with the generators, and with $\overline{Z_j}$ for $j \neq i$, anti-commute for 
$j = i$. 

\subsection{Quatum circuits for encoding, decoding and correction}
One of the features of stabilizer codes is that their structure enables systematic contruction 
of procdures for encoding, decoding and error-correction. Let us consider 
the general case, i.e $C(S)$ is an $[n,k]$ stabilizer code with generators $g_1, \cdots, g_{n-k}$ and 
logiacl $Z$ operators $\overline{Z_1}, \cdots, \overline{Z_k}$. 

\paragraph{Encoding} Preparing an encoded $\ket{0}^{\otimes k}$ state is quite simple. 
To do this, we start with any easily prepared state like $\ket{0}^{\otimes n}$ and measure each of the 
observables $g_1, \cdots, g_{n-k}, Z_1, \cdots Z_k$. Depending on the measurment outcomes, the resulting state will 
have stabilizer 
$$\langle \pm g_1, \cdots, \pm g_{n-k}, \pm Z_1, \cdots, \pm Z_k\rangle$$ 
The signs of all the stabilizer generators and the $\overline{Z_j}$ can then be fixed by applying products of 
Pauli operators, giving us a state stabilized by 
$$\langle g_1, \cdots, g_{n-k}, \overline{Z_1}, \cdots, \overline{Z_k} \rangle$$

Once this state is prepared, we can encode any logical state $\ket{x_1 \cdots x_k}$ by applying the corresponding 
logical $X$ operators. 

\paragraph{Decoding} Decoding quantum codes is also simple, however in many cases we don't even need a full decoding. 
It turns out that the techniques of fault-tolerant quantum computation can be used to perform logical operations on 
encoded data, without the need for decoding. 
Moreover, the output of such a computation can be determined simply by measuring the logical $Z$ operators. 

\paragraph{Error-correction} The error-correction procedure has already been described above, 
and is much like the encoding procedure: simply measure each of the generators $g_1, \cdots, g_{n-k}$ 
in turn, obtaining the syndrome $\beta_1, \cdots, \beta_{n-k}$. Classical computation is then used to 
determine the required recovery operation $E_j^\dagger$. 

\paragraph{Projecting an opreator}
In all three cases, the  key is to understand how to measure operators. 
This is a generalization of the normal projective measurments we have widely used, 
in which we project a state into an eigenstate of the operator and to obtain both the 
projected state, and an indicator of the eigenvalue. 

Notice that given a gate that performs a controlled-$M$ operation ($M$ on $n$ qubits with eigenvalues $\pm 1$), we can easily 
construct a circuit that performs a measurement of the $M$ operator. In this case, $M$ would be 
the product of Paulis, which we need to measure during the encoding, decoding and error correction procedures for stabilizer codes. 

Notice that this means that all these circuits can be implemented only using Clifford gates. 

\section{Fault-tolerant Quantum computation}
One of the most powerful applications of QEC is the fact that we can protect information 
\emph{dynamically} while it undergoes \emph{computation}. 
It turns out that arbitrarily good quantum computation can be achieved even with faulty quantum gates, given 
that the error probability per gate is below a certain constant \emph{treshold}. 

\subsection{The big picture} 
The basic idea of fault-tolerant quantum computation is to compute directly on \emph{encoded quantum states} 
so that we never need to decode. Given a circuit, we replace each qubit with an \emph{encoded block} of qubits, 
and replace every gate with a \emph{procedure} for performing an \emph{encoded gate}. 
Since errors can propagate, we also design our encoded states so that failure anywhere in the circuit 
can propagate to a small number of qubits in each block so that error correction 
will be effective. Such procedures are referred to as \emph{fault-tolerant} procedures. 

We also must keep in mind that error-correction itself can introduce new errors on the encoded qubits. 
This can be taken care of by using techniques similar to those used to prevent propagation of errors. 

\paragraph{Fault-tolerant operations} 
\begin{definition}
  We defin a \emph{fault-tolerant} procedure to be a procedure such that if only one component of the procedure fails, 
  the we have at most one error in each encoded block of qubits output from the procedure.

  Similarly, a procedure for measuing an observable on a set of encoded qubits is said to be \emph{fault-tolerant} 
  if the failure of any single component in the procedure results in an error in at most one qubit at the output of the procedure. 
  Furthermore, we require that the measurment result reported must have probability of error $O(p^2)$, where $p$ 
  is the probability of failure in any one of the components.
\end{definition}

To simplify the analysis, we suppose that errors on qubits are one of four types: $I, X, Y, Z$ happening randomly with 
approriate probabilities. We also allow corrolated errors between two qubits (e.g propagation during a CNOT), but these must be tensor product of Paulis. 

For any quantum gate such that the individual components might fail with probability $p$, the 
encoded probability succeds with probability $1 - cp^2$ (we use $c \approx 10^{4}$) which means that 
for small $p$, there is a net gain to using the econded procedure: we reduce the probability of failure 
from $p$ to $cp^2$.

\paragraph{Concatenated codes and the treshold theorem} This construction is based on 
classical \emph{concatenated codes} which can be used to reduce the error rate achieved by computation even further. 
The idea is to recursively apply the scheme described above for simulating a circuit using an encoded circuit, 
constructing a hierarchy of quantum circuits $C_0, C_1, C_2, \cdots$ The construction is done in stages: \\
In the first stage of construction, any given gate in $C_0$ is replaced in $C_1$ by a procedure performing an 
encoded gate and error-correction. Then, each of the components in $C_1$ are replaced in $C_2$ by a fault-tolerant procedure 
implementing an encoded version of the component, and error-correction, and so on. If we concatenate $k$ times, the failure probability 
at the highest level is $(cp)^2k / c$, whiel the size of the circuit is $d^k$ times the size of the original circuit, 
where $d$ is a constant representing the amximum number of operations used in a fault-tolerant procedure. 

Suppose then that we want to simulate a circuit containing $p(n)$ gates, with a final 
accuracy of $\varepsilon$ in our final simulation. To do so, each gate in the algorithm must 
be simulated with $\varepsilon / p(n)$ accuracy, so we need $k$ such that 
$$\frac{(cp)^2k}{c} \leq \frac{\varepsilon}{p(n)}$$
Let $p_{th} = 1/c$, therefore provided $l < p_{th}$ such a $k$ can be found. The condition $p < p_{th}$ is known as the 
\emph{treshold condition} for quantum computation, since provided it is satisfied, we can achieve arbitary accuracy in our quantum computations. 

\begin{theorem}[Treshold theorem for quantum computation]
  A quantum circuit containing $p(n)$ gates may be simulated with probability of error at most $\varepsilon$ using 
  $$O\left(poly\left(log (p(n) / \varepsilon)\right) p(n)\right)$$
  gates whose components fail with at most probability $p$, provided that $p < p_{th}$. 
\end{theorem}

\subsection{Fault-tolerant quantum logic}
Recall that the $H, S, CNOT$ and $\pi/8$ gates form a universal set. We wish to express how each 
of these gates can be implemented fault-tolerantly. 

\paragraph{Normalizer operators} 
The goal is to build fault-tolerant normalizer operations ($H, S, CNOT$ gates). Notice that gates are automatically fault-tolerant 
if they can be implemented in a bitwise fashion (since we can insert $U U^\dagger = I$), since this ensures that errors aren't propagated. 
We call this property the \emph{tranversality} property of an encoded quantum gate. Examples of this kind of gate in the Steane code 
include the Clifford gates (even the $CNOT$ gate since the error may propagate forward or backwards to another block) but exclude the $\pi / 8$ gate.   

\paragraph{The $\pi/8$ gate}
The strategy to construct the fault-tolerant $\pi/8$ gate is to split to construction into three parts. 
The first part is to simulate the $\pi/8$ using elements we know how do fault-tolerantly (Clifford gate). However, 
there are two parts which we don't know (yet) how to make fault tolerant. 
\begin{itemize}
  \item The preparation of the \emph{ancilla state} for input into the circuit. 
  \item Measurement, the failure of a single component during measurment shouldn't affect the measurment outcome. 
\end{itemize}
The circuit used to simulate the $\pi / 8$ gate can be observed at page $486$. 
Note that this construction requires a fault-tolerant method to prepare 
$$\ket{\Theta} = \frac{\ket{0} + e^{i \pi / 4} \ket{1}}{\sqrt{2}}$$
Notice that $\ket{\Theta}$ may be produced by applying an $H$ gate then a $\pi/8$ gate. 
Since $\ket{0}$ is a $+1$ eigenstate of $Z$, $\ket{\Theta}$ is a $+1$ eigenstate of 
$$THZHT^\dagger = TXT^\dagger = e^{- i \pi/4} SX$$
So $\Theta$ can then be prepared by first preparing $\ket{0}$ then fault-tolerantly measuring $e^{-i \pi / 4} SX$ 
with appropriate action after measurment (either discarding and repeating or applying $ZSXZ = - SX$ when $-1$). 
Note that this relies on fault-tolerant measurment, which introduces nicely the next section. 

\subsection{Fault-tolerant measurment} 
Measurements are used to encode, read out results, diagnose syndrome, and to do ancilla state preparation, and 
therefore are critical for fault-tolerant quantum computation. To consider a measurement to be \emph{fault-tolerant}, 
we require that two things be true: 
\begin{enumerate}
  \item A single failure anywhere in the procedure should lead to at most one error in any block of qubits at the end. 
  \item Even if a single failure occurs, we require that the result be correct with probability $1 - O(p^2)$. 
\end{enumerate}

Suppose we want to measure a single qubit observable $M$. Suppose $M$ can be given a tranversal encoded implementation 
on a quantum code as bitwise application of some $M'$ to each qubit. Then we can measure $M$ fault-tolerantly on the 
encoded data. By this we mean that single errors will not propagate and that we have an $O(p^2)$ probability of obtaining a wrong 
measurment. 

\section{Toric codes} 
Note that the reference used for toric codes is concise and clear, so this will just cover the core concepts in 
case I need a quick reminder. \\
The \emph{toric code} is a $CSS$ code defined on the torus. Therefore we must introduce some new notation. 
 
\subsection{The torus} 
We cellulate the torus by laying a square grid on the surface. 
We have three types of objects of interest: 
\begin{itemize}
  \item Vertices: Where two lines intersect. 
  \item Edges: the segment connecting two neighboring vertices. 
  \item Plaquettes: the squares formed by four neighboring edges. 
\end{itemize}
Notice that in an $L \times L$ torus, there are $L^2$ vertices and plaquettes, whereas there 
are $2 L^2$ edges. 

\subsection{Classical codes on the Torus} 
Like all $CSS$ codes, before defining the Toric code we need to define two classical codes on the torus. Note that bistrings for codewords 
are read from left to right, and from top to bottom. The codes on the Torus are
\begin{itemize}
  \item \emph{The vertex code $C_x$}, there will be a parity in $C_x$ for each vertex on the Torus. This parity check enforces 
  that the number of $1$'s on the edges incident to $v$ must be even. 

  \item \emph{The plaquette code $C_z$}, there will be a parity check in $C_z$ enforcing that the 
  number of $1$'s on the edges bordering the plaquette $p$ must be even. 
\end{itemize}
Now that $C_x$ and $C_z$ have been defined, it can easily be show that $C_x$ and $C_z$ can be used 
to form a CSS code (since $\forall h_x, h_z \in C_x^{\perp}, C_z^\perp, \, h_x \cdot h_z = 0$).  
More precisely, we have that 
$$C_z \subseteq C_x^\perp \text{ or equivalently } C_x \subseteq C_Z^\perp$$

\paragraph{Properties of these classical codes}
We start by describing all the strings in $C_x$: \\
Imagine flipping on a bit on some edge $e = \{u, v\}$ (on the empty grid for example). The two parity checks centered at $u$ and $v$ are now violated. 
To restore these, we flip another bit at edges incident to these two vertices, which in turn violates two new 
parity checks. This process continues forming a path of $1$s in the grid until the two endpoints meet to form a closed loop. 
Therefore, the strings in $C_x$ correspond to the edges of \emph{closed loops} in the grid, and their linear combinations. 
\begin{corollary}
  The distance of $C_x$ is at most $4$ for any $L$, this is because we can always turn on the $4$ edges of a 
  plaquette. 
\end{corollary}

Also note that since $C_z^\perp \susbeteq C_x$, the border of any set of plaquettes is a set of closed loops. 
Additionally, the set of all plaquette parity checks in $C_z^\perp$ is not independent because every edge borders two 
plaquettes, so 
$$\sum_p h_{z,p} = 0$$
where the sum is taken over all plaquettes. However, if we take any proper subset of the set of plaquettes, and sum over thoes 
parity checks, we get a non-zero answer. So for any particular plaquette $p^*$, the set 
$\{h_{z,p}\}_{p \neq p^*}$ forms a basis for $C_z^\perp$. So the dimension of $C_z^\perp$ is $L^2 - 1$. 

To understand the structure of the codewords in $C_z$ and parity checks in $C_x^\perp$, we make use of the Dual Lattice (view reference). This dual 
lattice is isomorphic to the original lattice, but parity checks on the plaquettes map to $C_x$ and on the edges to $C_z$. Therefore we can apply the same reasonning 
in the dual lattice (which is also $L \times L$) to understand the structure of $C_z$ and $C_x^\perp$. 

\subsection{Consrtucting the Toric code} 
The toric code is simply the quantum $CSS$ code resulting from $C_x$ and $C_z^\perp$. 
Its stabilizers are generated by Paulis of the form $X^v$ (which denotes an $X$ operators applied to the qubits on the edges incident to vertex $v$). 
and $Z^p$ (which denotes a $Z$ operator applied to the qubits on the edges of plaquette $p$). 

The number of physical qubits is the number of edges, which is $2L^2$. The number of logical qubits is $2L^2$ minus 
the number of independent parity checks in $C_x^\perp$ and $C_z^\perp$. Therefore the number of logical qubits is 
$$2 L^2 - (L^2 - 1) - (L^2 - 1) = 2$$
Moreover, we can easily deduce that $d \leq 4$. 

The lements of $C_x$ are the set of all closed loops in the Torus, and $C_z^\perp$ is the set 
of all loops that are boundaries of plaquettes. The set $C_x / C_z^\perp$ is then the set of all 
loops that go around the torus. In the quantum setting, these correspond to the Pauli strings that commute with 
all the $X^v$ operators, but are not products of $Z^p$ operators. These are the non-contractible loops 
consisting of $Z$ operations. 

Since the smallest non-contractible loop has to go all the way around the torus, $d_x^+ = L$, which 
is much better than teh distance of $4$ achieved by the two classical codes on their own. This indicates that 
the code is highky degenerate. All the contractible loops are errors in the classical codes, but correspond to no error 
in the quantum code. 

so the parameters for the toric code are: 
$$[2L^2, 2, L]$$

\section{References}
The material is adapted from: 
\begin{quote}
\textbf{A. Nielsen and I. Chuang's} book \emph{Quantum Computation and Quantum Information} (Cambridge University Press, 2010).
\end{quote}
Page or chapter references will are given in the text where relevant. 
\end{document}
\usetikzlibrary{matrix,decorations.pathreplacing}